<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>ğŸ‘” ì§§ì€ ê·¸ë¦¼ ë¦¬í¼ì‹¤</title>

    <!-- [iOS PWA ì„¤ì •] -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="apple-mobile-web-app-title" content="ë¦¬í¼ì‹¤" />
    <link
      rel="apple-touch-icon"
      href="https://toastout.github.io/toast/icon.png"
    />

    <style>
      :root {
        --bg-color: #f8f9fa;
        --text-color: #212529;
        --border-color: #dee2e6;
        --section-bg: #ffffff;
        --btn-bg: #e9ecef;
        --btn-hover-bg: #dee2e6;
        --accent-btn-bg: #228be6;
        --accent-btn-hover-bg: #1c7ed6;
        --tool-active-bg: #e7f5ff;
        --tool-active-color: #1971c2;
        --danger-color: #fa5252;
      }
      body.dark {
        --bg-color: #121212;
        --text-color: #e9ecef;
        --border-color: #343a40;
        --section-bg: #1e1e1e;
        --btn-bg: #343a40;
        --btn-hover-bg: #495057;
        --tool-active-bg: #1864ab;
        --tool-active-color: #e7f5ff;
      }

      * {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        font-family: "Pretendard", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: var(--bg-color);
        color: var(--text-color);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        min-height: 100vh;
        box-sizing: border-box;
        overscroll-behavior: none;
        -webkit-user-select: none;
        user-select: none;
        padding-top: env(safe-area-inset-top);
      }

      input[type="text"],
      input[type="number"] {
        -webkit-user-select: text;
        user-select: text;
      }

      .container {
        width: 100%;
        max-width: 600px;
        background-color: var(--section-bg);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 25px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      }
      h1 {
        text-align: center;
        margin-top: 0;
      }
      p.subtitle {
        color: var(--key-color, #868e96);
        line-height: 1.6;
        text-align: center;
        margin-bottom: 30px;
      }

      /* ì—…ë¡œë“œ ì˜ì—­ */
      .upload-box {
        border: 2px dashed var(--border-color);
        border-radius: 8px;
        padding: 40px 20px;
        cursor: pointer;
        text-align: center;
        transition: all 0.2s;
        min-height: 200px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .upload-box:hover,
      .upload-box.dragover {
        background-color: var(--bg-color);
        border-color: var(--accent-btn-bg);
      }

      /* ìº”ë²„ìŠ¤ ì˜ì—­ */
      #workspace {
        display: none;
        text-align: center;
      }
      #canvas-wrapper {
        position: relative;
        display: inline-block;
        margin: 10px auto;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        touch-action: none;
        max-width: 100%;
      }
      canvas {
        display: block;
        max-width: 100%;
        height: auto;
        cursor: crosshair;
      }

      /* ë„êµ¬ íŒ¨ë„ */
      .toolbar {
        display: flex;
        flex-direction: column;
        gap: 10px;
        background: var(--bg-color);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 15px;
        border: 1px solid var(--border-color);
        align-items: center;
      }
      .tool-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: center;
        width: 100%;
      }

      .tool-btn {
        background: var(--btn-bg);
        color: var(--text-color);
        border: none;
        width: 42px;
        height: 42px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1.2rem;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      .tool-btn:hover {
        background-color: var(--btn-hover-bg);
      }
      .tool-btn.active {
        background-color: var(--tool-active-bg);
        color: var(--tool-active-color);
        font-weight: bold;
        border: 1px solid var(--tool-active-color);
      }

      .small-btn {
        width: auto;
        padding: 0 10px;
        font-size: 0.9rem;
        height: 36px;
      }

      /* ì˜µì…˜ íŒ¨ë„ */
      #tool-options {
        display: flex;
        gap: 10px;
        justify-content: center;
        align-items: center;
        margin-top: 5px;
        min-height: 40px;
        flex-wrap: wrap;
      }

      .size-indicator {
        font-size: 0.8rem;
        color: var(--text-color);
        min-width: 30px;
        text-align: center;
        font-variant-numeric: tabular-nums;
      }

      input[type="color"] {
        width: 30px;
        height: 30px;
        border: none;
        background: none;
        cursor: pointer;
        padding: 0;
        border-radius: 50%;
        overflow: hidden;
        border: 1px solid var(--border-color);
      }
      input[type="range"] {
        width: 100px;
        cursor: pointer;
      }
      input[type="text"] {
        padding: 6px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--section-bg);
        color: var(--text-color);
        width: 80px;
        text-align: center;
      }
      .checkbox-label {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 0.8rem;
        cursor: pointer;
        user-select: none;
      }

      /* ìë¥´ê¸° íŒ¨ë„ */
      #crop-panel {
        display: none;
        gap: 10px;
        justify-content: center;
        background: var(--bg-color);
        padding: 10px;
        border-radius: 8px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }
      #crop-panel.active {
        display: flex;
      }

      /* í•˜ë‹¨ ë²„íŠ¼ ë° ë¦¬ì‚¬ì´ì¦ˆ ì»¨íŠ¸ë¡¤ */
      .action-panel {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 20px;
      }

      .resize-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        flex-wrap: wrap;
        font-size: 0.9rem;
        background: var(--btn-bg);
        padding: 10px;
        border-radius: 8px;
      }
      .resize-btns {
        display: flex;
        gap: 5px;
      }
      .resize-btns button {
        padding: 4px 8px;
        font-size: 0.8rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--section-bg);
        cursor: pointer;
        color: var(--text-color);
      }

      .download-buttons {
        display: flex;
        gap: 10px;
      }
      .download-buttons button {
        flex: 1;
        border: none;
        padding: 15px;
        border-radius: 8px;
        font-size: 1.1rem;
        font-weight: 600;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .download-buttons button:disabled {
        background-color: var(--btn-bg);
        color: #adb5bd;
        cursor: not-allowed;
      }
      #reform-btn {
        background-color: var(--accent-btn-bg);
        color: #fff;
      }
      #reform-btn:hover:not(:disabled) {
        background-color: var(--accent-btn-hover-bg);
      }

      /* ìœ í‹¸ë¦¬í‹° */
      .header-controls {
        position: fixed;
        top: 20px;
        right: 20px;
        display: flex;
        gap: 10px;
        z-index: 100;
      }
      .header-controls button,
      .header-controls a {
        background-color: var(--btn-bg);
        color: var(--text-color);
        border: none;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        text-decoration: none;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
        font-size: 1rem;
      }
      .header-controls button:hover,
      .header-controls a:hover {
        background-color: var(--btn-hover-bg);
      }

      #change-image-btn {
        width: 100%;
        background-color: var(--btn-bg);
        color: var(--text-color);
        border: none;
        padding: 10px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        margin-bottom: 10px;
      }

      @media (max-width: 480px) {
        .container {
          padding: 15px;
        }
        .tool-btn {
          width: 38px;
          height: 38px;
          font-size: 1.1rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="header-controls">
      <a href="https://toastout.github.io/toast/" title="ëŒì•„ê°€ê¸°">ğŸ</a>
      <a
        href="https://toastout.github.io/toast5/"
        title="ì§§ì€ ê·¸ë¦¼ ì„¸íƒì†Œ(ì„¸íƒ, ì›Œí„°ë§ˆí¬)"
        >ğŸ§¼</a
      >
      <a
        href="https://toastout.github.io/toast13/"
        title="ê³µìœ  ì‘ì—…ì‹¤(ì´ì–´ë¶™ì´ê¸°)"
        >ğŸ–¼ï¸</a
      >
    </div>

    <div class="container">
      <h1>ğŸ‘” ì§§ì€ ê·¸ë¦¼ ë¦¬í¼ì‹¤</h1>
      <p class="subtitle">
        ğŸ¨ JPG ë³€í™˜ (ë©”íƒ€ë°ì´í„° ì œê±°)<br />+ ğŸ§¶ ì§ì ‘ ê·¸ë ¤ì„œ ë¦¬í¼í•˜ê¸°
      </p>

      <div id="upload-box" class="upload-box">
        <span style="font-size: 2rem">ğŸ–¼ï¸</span>
        <p>ì‘ì—…í•  ì´ë¯¸ì§€ë¥¼ ì—¬ê¸°ì— ì˜¬ë ¤ì£¼ì„¸ìš”</p>
      </div>
      <input
        type="file"
        id="file-input"
        accept="image/*"
        style="display: none"
      />
      <input
        type="file"
        id="layer-input"
        accept="image/*"
        style="display: none"
      />

      <div id="workspace">
        <button id="change-image-btn">ğŸ–¼ï¸ ë‹¤ë¥¸ ì‘ì—…ë¬¼ ê°€ì ¸ì˜¤ê¸°</button>

        <div id="crop-panel">
          <span style="font-size: 0.9rem; align-self: center"
            >âœ‚ï¸ ì˜ì—­ì„ ë“œë˜ê·¸í•˜ì„¸ìš”</span
          >
          <button
            class="tool-btn small-btn active"
            id="btn-apply-crop"
            style="color: white; background: var(--accent-btn-bg)"
          >
            ì ìš©
          </button>
          <button class="tool-btn small-btn" id="btn-cancel-crop">ì·¨ì†Œ</button>
        </div>

        <div class="toolbar">
          <!-- 1ì¸µ: ê·¸ë¦¬ê¸° ë„êµ¬ -->
          <div class="tool-row">
            <button class="tool-btn active" id="tool-pen" title="íœ">ğŸ–Œï¸</button>
            <button class="tool-btn" id="tool-highlighter" title="í˜•ê´‘íœ">
              ğŸ–ï¸
            </button>
            <button class="tool-btn" id="tool-mosaic" title="ëª¨ìì´í¬">
              ğŸ’§
            </button>
            <button class="tool-btn" id="tool-eraser" title="ì§€ìš°ê°œ">ğŸ§½</button>
            <!-- 2ì¸µ: ìŠ¤í‹°ì»¤ & íŒ¨ì¹˜ -->
            <button class="tool-btn" id="tool-sticker" title="ì´ëª¨ì§€ ìŠ¤í‹°ì»¤">
              ğŸ˜‡
            </button>
            <button class="tool-btn" id="tool-patch" title="ë‹¨ìƒ‰ íŒ¨ì¹˜">
              ğŸ¡
            </button>
          </div>

          <!-- 3ì¸µ: ê¸°íƒ€ ë„êµ¬ -->
          <div class="tool-row">
            <button class="tool-btn" id="tool-text" title="í…ìŠ¤íŠ¸">T</button>
            <button class="tool-btn" id="tool-photo" title="ì‚¬ì§„ í•©ì¹˜ê¸°">
              ğŸ“¸
            </button>
            <button class="tool-btn" id="tool-crop" title="ìë¥´ê¸°">âœ‚ï¸</button>
            <button class="tool-btn" id="tool-filter" title="í‘ë°± í•„í„° ON/OFF">
              ğŸï¸
            </button>
            <!-- ì§€í•˜ 1ì¸µ: ì‹¤í–‰ ì·¨ì†Œ/ì´ˆê¸°í™” -->
            <button class="tool-btn" id="btn-undo" title="ë˜ëŒë¦¬ê¸°">â†©ï¸</button>
            <button class="tool-btn" id="btn-reset" title="ì´ˆê¸°í™”">ğŸ—‘ï¸</button>
          </div>

          <!-- ì˜µì…˜ íŒ¨ë„ (ë™ì  ë³€ê²½) -->
          <div id="tool-options">
            <!-- ì—¬ê¸°ì— JSë¡œ ì˜µì…˜ ì»¨íŠ¸ë¡¤ì´ ë“¤ì–´ì˜µë‹ˆë‹¤ -->
          </div>
        </div>

        <div id="canvas-wrapper">
          <canvas id="main-canvas"></canvas>
        </div>

        <div class="action-panel">
          <!-- ì‹¤ì‹œê°„ ë¦¬ì‚¬ì´ì§• ì»¨íŠ¸ë¡¤ -->
          <div class="resize-controls">
            <label>ì¶œë ¥ í¬ê¸°:</label>
            <input
              type="number"
              id="img-width"
              placeholder="ë„ˆë¹„"
              style="width: 70px; padding: 5px; text-align: center"
            />
            <span>x</span>
            <input
              type="number"
              id="img-height"
              placeholder="ë†’ì´"
              style="width: 70px; padding: 5px; text-align: center"
              readonly
            />
            <div class="resize-btns">
              <button data-percent="0.5">50%</button>
              <button data-percent="0.75">75%</button>
              <button data-percent="1.0">100%</button>
            </div>
          </div>

          <div class="download-buttons">
            <button id="reform-btn" title="ë¦¬í¼ëœ ì´ë¯¸ì§€ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.">
              ğŸ§¶ ë¦¬í¼ (ìˆ˜ì •ë³¸ ì €ì¥)
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // [iOS ìµœì í™”]
        document.addEventListener(
          "dblclick",
          function (event) {
            event.preventDefault();
          },
          { passive: false }
        );

        // --- Elements ---
        const uploadBox = document.getElementById("upload-box");
        const fileInput = document.getElementById("file-input");
        const layerInput = document.getElementById("layer-input");
        const workspace = document.getElementById("workspace");
        const canvas = document.getElementById("main-canvas");
        const ctx = canvas.getContext("2d");
        const widthInput = document.getElementById("img-width");
        const heightInput = document.getElementById("img-height");
        const reformBtn = document.getElementById("reform-btn");
        const resizeBtns = document.querySelectorAll(".resize-btns button");

        // Tools Buttons
        const tools = {
          pen: document.getElementById("tool-pen"),
          highlighter: document.getElementById("tool-highlighter"),
          mosaic: document.getElementById("tool-mosaic"),
          eraser: document.getElementById("tool-eraser"),
          sticker: document.getElementById("tool-sticker"),
          patch: document.getElementById("tool-patch"),
          photo: document.getElementById("tool-photo"),
          text: document.getElementById("tool-text"),
          crop: document.getElementById("tool-crop"),
          filter: document.getElementById("tool-filter"),
        };

        // UI Panels
        const toolOptions = document.getElementById("tool-options");
        const cropPanel = document.getElementById("crop-panel");
        const btnUndo = document.getElementById("btn-undo");
        const btnReset = document.getElementById("btn-reset");
        const btnApplyCrop = document.getElementById("btn-apply-crop");
        const btnCancelCrop = document.getElementById("btn-cancel-crop");

        // Options UI
        const elColor = document.createElement("input");
        elColor.type = "color";
        elColor.value = "#000000";
        const elSize = document.createElement("input");
        elSize.type = "range";
        elSize.min = 1;
        elSize.max = 100;
        elSize.value = 10;
        const elSizeLabel = document.createElement("span");
        elSizeLabel.className = "size-indicator";
        elSizeLabel.textContent = "10"; // ì‚¬ì´ì¦ˆ í‘œê¸°
        const elTextInput = document.createElement("input");
        elTextInput.type = "text";
        elTextInput.placeholder = "ë‚´ìš©";
        const elStickerInput = document.createElement("input");
        elStickerInput.type = "text";
        elStickerInput.value = "ğŸ˜º";
        elStickerInput.style.width = "40px";
        const elBgCheck = document.createElement("input");
        elBgCheck.type = "checkbox";
        const elBgColor = document.createElement("input");
        elBgColor.type = "color";
        elBgColor.value = "#ffffff";
        elBgColor.disabled = true;
        const elPatchRect = document.createElement("button");
        elPatchRect.className = "tool-btn small-btn active";
        elPatchRect.textContent = "â– ";
        const elPatchCircle = document.createElement("button");
        elPatchCircle.className = "tool-btn small-btn";
        elPatchCircle.textContent = "â—";
        const elChangePhoto = document.createElement("button");
        elChangePhoto.className = "tool-btn small-btn";
        elChangePhoto.textContent = "ğŸ”„ ì‚¬ì§„ êµì²´";
        const lblBg = document.createElement("label");
        lblBg.className = "checkbox-label";
        lblBg.appendChild(elBgCheck);
        lblBg.append(" ë°°ê²½");

        // State
        let originalImg = null;
        let customPhotoImg = null;
        let history = [];
        let currentMode = "pen";
        let isDrawing = false;
        let currentPath = [];
        let patchShape = "rect";
        let isFilterOn = false;

        let isCropping = false;
        let cropStart = null;
        let cropCurrent = null;

        // --- Functions ---

        function handleFile(file) {
          if (!file || !file.type.startsWith("image/"))
            return alert("ì´ë¯¸ì§€ íŒŒì¼ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.");
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              originalImg = img;
              history = [];
              isFilterOn = false;
              tools.filter.classList.remove("active");

              // ì´ˆê¸°ê°’: ì›ë³¸ í¬ê¸°
              widthInput.value = img.naturalWidth;
              heightInput.value = img.naturalHeight;

              initCanvas(img.naturalWidth, img.naturalHeight);

              uploadBox.style.display = "none";
              workspace.style.display = "block";
              updateUI();
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        }

        function handleLayerFile(file) {
          if (!file || !file.type.startsWith("image/"))
            return alert("ì´ë¯¸ì§€ íŒŒì¼ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.");
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              customPhotoImg = img;
              setMode("photo");
              alert("ì‚¬ì§„ì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤. ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•˜ì—¬ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.");
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        }

        // Canvas Resizing Logic (Live)
        function initCanvas(w, h) {
          if (!originalImg) return;

          canvas.width = w;
          canvas.height = h;

          // CSS Display size (responsive)
          const wrapper = document.getElementById("canvas-wrapper");
          const maxWidth = Math.min(600, window.innerWidth - 50);
          let displayWidth = w;
          let displayHeight = h;

          if (displayWidth > maxWidth) {
            const ratio = maxWidth / displayWidth;
            displayWidth = maxWidth;
            displayHeight = h * ratio;
          }
          canvas.style.width = `${displayWidth}px`;
          canvas.style.height = `${displayHeight}px`;

          redraw();
        }

        // Live Resize Event
        function updateCanvasSize() {
          if (!originalImg) return;
          let newW = parseInt(widthInput.value);
          if (!newW || newW < 1) newW = 100;

          // Aspect ratio maintained
          const ratio = originalImg.naturalHeight / originalImg.naturalWidth;
          const newH = Math.round(newW * ratio);
          heightInput.value = newH;

          initCanvas(newW, newH);
        }

        widthInput.addEventListener("input", updateCanvasSize);

        resizeBtns.forEach((btn) => {
          btn.addEventListener("click", () => {
            if (!originalImg) return;
            const percent = parseFloat(btn.dataset.percent);
            widthInput.value = Math.round(originalImg.naturalWidth * percent);
            updateCanvasSize();
          });
        });

        // --- Redraw Logic (Scale-Aware) ---
        function redraw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // 1. Draw Background
          ctx.filter = isFilterOn ? "grayscale(100%)" : "none";
          // Draw original image scaled to current canvas size
          ctx.drawImage(originalImg, 0, 0, canvas.width, canvas.height);
          ctx.filter = "none";

          // 2. Layers
          // History points are stored relative to *Original Natural Width*
          // So we need to scale them to *Current Canvas Width*
          const scaleX = canvas.width / originalImg.naturalWidth;
          const scaleY = canvas.height / originalImg.naturalHeight;

          // Use an offscreen canvas for drawing layers to handle blending correctly
          const drawCanvas = document.createElement("canvas");
          drawCanvas.width = canvas.width;
          drawCanvas.height = canvas.height;
          const dCtx = drawCanvas.getContext("2d");
          dCtx.lineCap = "round";
          dCtx.lineJoin = "round";

          history.forEach((action) => {
            dCtx.globalCompositeOperation = "source-over";
            dCtx.globalAlpha = 1.0;

            // Coordinates scaling
            const ax = action.x * scaleX;
            const ay = action.y * scaleY;
            const as = action.size * scaleX; // Size also scales!

            if (action.type === "path") {
              dCtx.beginPath();
              dCtx.lineWidth = as;

              if (action.mode === "eraser")
                dCtx.globalCompositeOperation = "destination-out";
              else if (action.mode === "highlighter") {
                dCtx.globalCompositeOperation = "multiply";
                dCtx.globalAlpha = 0.3;
                dCtx.strokeStyle = action.color;
              } else if (action.mode === "mosaic") {
                /* ... */
              } else {
                dCtx.strokeStyle = action.color;
              }

              if (action.points.length > 0) {
                dCtx.moveTo(
                  action.points[0].x * scaleX,
                  action.points[0].y * scaleY
                );
                for (let i = 1; i < action.points.length; i++) {
                  dCtx.lineTo(
                    action.points[i].x * scaleX,
                    action.points[i].y * scaleY
                  );
                }
              }

              if (action.mode === "mosaic") {
                dCtx.save();
                dCtx.stroke();
                dCtx.clip();
                dCtx.filter = "blur(5px)";
                dCtx.drawImage(originalImg, 0, 0, canvas.width, canvas.height);
                dCtx.restore();
                dCtx.filter = "none";
              } else {
                dCtx.stroke();
              }
            } else if (action.type === "stamp") {
              dCtx.font = `${as}px "Pretendard", "Apple Color Emoji", sans-serif`;
              dCtx.textAlign = "center";
              dCtx.textBaseline = "middle";
              if (action.bgColor) {
                const metrics = dCtx.measureText(action.text);
                const tw = metrics.width;
                const p = as * 0.2;
                dCtx.fillStyle = action.bgColor;
                roundRect(
                  dCtx,
                  ax - tw / 2 - p,
                  ay - as / 2 - p,
                  tw + p * 2,
                  as + p * 2,
                  8 * scaleX
                );
                dCtx.fill();
              }
              dCtx.fillStyle = action.color || "#000";
              dCtx.fillText(action.text, ax, ay);
            } else if (action.type === "image") {
              const imgW = action.width * scaleX;
              const imgH = action.height * scaleY;
              dCtx.drawImage(
                action.img,
                ax - imgW / 2,
                ay - imgH / 2,
                imgW,
                imgH
              );
            } else if (action.type === "patch") {
              dCtx.fillStyle = action.color;
              dCtx.beginPath();
              if (action.shape === "rect")
                dCtx.fillRect(ax - as / 2, ay - as / 2, as, as);
              else {
                dCtx.arc(ax, ay, as / 2, 0, Math.PI * 2);
                dCtx.fill();
              }
            }
          });

          ctx.drawImage(drawCanvas, 0, 0);

          if (currentMode === "crop" && cropStart && cropCurrent)
            drawCropOverlay();
          reformBtn.disabled = !(history.length > 0 || isFilterOn);
        }

        function drawCropOverlay() {
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          // Coordinates for crop are in Canvas pixels.
          // Logic remains same as they are transient.
          const x = Math.min(cropStart.x, cropCurrent.x);
          const y = Math.min(cropStart.y, cropCurrent.y);
          const w = Math.abs(cropCurrent.x - cropStart.x);
          const h = Math.abs(cropCurrent.y - cropStart.y);

          ctx.fillRect(0, 0, canvas.width, y);
          ctx.fillRect(0, y + h, canvas.width, canvas.height - (y + h));
          ctx.fillRect(0, y, x, h);
          ctx.fillRect(x + w, y, canvas.width - (x + w), h);
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
        }

        function roundRect(ctx, x, y, w, h, r) {
          if (w < 2 * r) r = w / 2;
          if (h < 2 * r) r = h / 2;
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.arcTo(x + w, y, x + w, y + h, r);
          ctx.arcTo(x + w, y + h, x, y + h, r);
          ctx.arcTo(x, y + h, x, y, r);
          ctx.arcTo(x, y, x + w, y, r);
          ctx.closePath();
        }

        // --- Interaction ---
        function getCoords(e) {
          const rect = canvas.getBoundingClientRect();
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          return {
            x: (clientX - rect.left) * (canvas.width / rect.width),
            y: (clientY - rect.top) * (canvas.height / rect.height),
          };
        }

        const startDraw = (e) => {
          const { x, y } = getCoords(e);
          if (currentMode === "crop") {
            isCropping = true;
            cropStart = { x, y };
            cropCurrent = { x, y };
            redraw();
            return;
          }

          const isPathTool = [
            "pen",
            "highlighter",
            "eraser",
            "mosaic",
          ].includes(currentMode);
          if (isPathTool) {
            isDrawing = true;
            // Store points in Original Scale!
            // Convert Canvas coords -> Original Coords
            const scaleX = originalImg.naturalWidth / canvas.width;
            const scaleY = originalImg.naturalHeight / canvas.height;
            currentPath = [{ x: x * scaleX, y: y * scaleY }];

            // Preview Dot (Draw directly on canvas)
            if (currentMode !== "mosaic") {
              ctx.beginPath();
              if (currentMode === "eraser") {
                ctx.fillStyle = "#ffffff";
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 1;
              } else {
                ctx.fillStyle = elColor.value;
              }
              if (currentMode !== "highlighter") {
                ctx.arc(x, y, elSize.value / 2, 0, Math.PI * 2);
                ctx.fill();
                if (currentMode === "eraser") ctx.stroke();
              }
            }
          }
        };

        const moveDraw = (e) => {
          const { x, y } = getCoords(e);
          if (currentMode === "crop" && isCropping) {
            e.preventDefault();
            cropCurrent = { x, y };
            redraw();
            return;
          }

          const isPathTool = [
            "pen",
            "highlighter",
            "eraser",
            "mosaic",
          ].includes(currentMode);
          if (!isDrawing || !isPathTool) return;
          e.preventDefault();

          // Save to path (Original Scale)
          const scaleX = originalImg.naturalWidth / canvas.width;
          const scaleY = originalImg.naturalHeight / canvas.height;
          currentPath.push({ x: x * scaleX, y: y * scaleY });

          // Real-time Visual (Canvas Scale)
          // Just draw the last segment to avoid full redraw lag
          ctx.beginPath();
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.lineWidth = elSize.value;

          if (currentMode === "eraser") {
            ctx.globalCompositeOperation = "destination-out";
            ctx.strokeStyle = "rgba(0,0,0,1)";
          } else if (currentMode === "mosaic") {
            ctx.globalCompositeOperation = "source-over";
            ctx.strokeStyle = "rgba(100,100,100,0.1)";
          } else if (currentMode === "highlighter") {
            ctx.globalCompositeOperation = "multiply";
            ctx.globalAlpha = 0.3;
            ctx.strokeStyle = elColor.value;
          } else {
            ctx.globalCompositeOperation = "source-over";
            ctx.strokeStyle = elColor.value;
          }

          // To draw line, we need previous point in Canvas scale
          // Previous point in path is in Original Scale
          const prevP = currentPath[currentPath.length - 2];
          const prevCanvasX = prevP.x / scaleX;
          const prevCanvasY = prevP.y / scaleY;

          ctx.moveTo(prevCanvasX, prevCanvasY);
          ctx.lineTo(x, y);
          ctx.stroke();

          ctx.globalCompositeOperation = "source-over";
          ctx.globalAlpha = 1.0;
        };

        const endDraw = (e) => {
          if (currentMode === "crop") {
            isCropping = false;
            return;
          }
          const isPathTool = [
            "pen",
            "highlighter",
            "eraser",
            "mosaic",
          ].includes(currentMode);

          // Scale factors for stamps
          const scaleX = originalImg.naturalWidth / canvas.width;
          const scaleY = originalImg.naturalHeight / canvas.height;

          if (isPathTool && isDrawing) {
            isDrawing = false;
            history.push({
              type: "path",
              mode: currentMode,
              color: elColor.value,
              size: parseInt(elSize.value) * scaleX, // Store size relative to original width!
              points: currentPath,
            });
            redraw();
          } else if (!isPathTool) {
            const { x, y } = getCoords(e);
            let size = parseInt(elSize.value);

            if (currentMode === "sticker") {
              history.push({
                type: "stamp",
                text: elStickerInput.value || "ğŸ˜º",
                x: x * scaleX,
                y: y * scaleY,
                size: size * scaleX,
              });
            } else if (currentMode === "patch") {
              history.push({
                type: "patch",
                shape: patchShape,
                color: elColor.value,
                x: x * scaleX,
                y: y * scaleY,
                size: size * scaleX,
              });
            } else if (currentMode === "text") {
              history.push({
                type: "stamp",
                text: elTextInput.value || "í…ìŠ¤íŠ¸",
                x: x * scaleX,
                y: y * scaleY,
                size: size * 3 * scaleX,
                color: elColor.value,
                bgColor: elBgCheck.checked ? elBgColor.value : null,
              });
            } else if (currentMode === "photo") {
              if (!customPhotoImg) {
                alert("ë¨¼ì € [ğŸ”„ ì‚¬ì§„ êµì²´] ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‚¬ì§„ì„ ì„ íƒí•´ì£¼ì„¸ìš”.");
                layerInput.click();
                return;
              }
              const aspect =
                customPhotoImg.naturalWidth / customPhotoImg.naturalHeight;
              const targetWidth = size * 2;
              const targetHeight = targetWidth / aspect;
              history.push({
                type: "image",
                img: customPhotoImg,
                x: x * scaleX,
                y: y * scaleY,
                width: targetWidth * scaleX,
                height: targetHeight * scaleX,
              });
            }
            redraw();
          }
        };

        canvas.addEventListener("mousedown", startDraw);
        canvas.addEventListener("mousemove", moveDraw);
        canvas.addEventListener("mouseup", endDraw);
        canvas.addEventListener("touchstart", startDraw, { passive: false });
        canvas.addEventListener("touchmove", moveDraw, { passive: false });
        canvas.addEventListener("touchend", endDraw);

        // --- Crop Action ---
        btnApplyCrop.addEventListener("click", () => {
          if (!cropStart || !cropCurrent)
            return alert("ìë¥¼ ì˜ì—­ì„ ì„ íƒí•´ì£¼ì„¸ìš”.");
          const x = Math.min(cropStart.x, cropCurrent.x);
          const y = Math.min(cropStart.y, cropCurrent.y);
          const w = Math.abs(cropCurrent.x - cropStart.x);
          const h = Math.abs(cropCurrent.y - cropStart.y);
          if (w < 10 || h < 10) return alert("ì˜ì—­ì´ ë„ˆë¬´ ì‘ìŠµë‹ˆë‹¤.");
          if (
            !confirm(
              "ìë¥´ê¸°ë¥¼ ì ìš©í•˜ë©´ ê¸°ì¡´ í¸ì§‘ ë‚´ì—­ì´ ì´ˆê¸°í™”ë©ë‹ˆë‹¤. ì§„í–‰í• ê¹Œìš”?"
            )
          )
            return;

          // Apply Crop on CURRENT canvas state
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = w;
          tempCanvas.height = h;
          const tCtx = tempCanvas.getContext("2d");

          // We crop from the *Current Canvas View* (filtered + original)
          // Note: Filters are applied in redraw(), so we can just grab from main canvas?
          // No, main canvas has overlays. We need to render the base image filtered + cropped.
          tCtx.filter = isFilterOn ? "grayscale(100%)" : "none";

          // Since originalImg is full size, and crop coords are in Canvas coords,
          // we need to map crop coords to Original Image coords.
          const scaleX = originalImg.naturalWidth / canvas.width;
          const scaleY = originalImg.naturalHeight / canvas.height;

          tCtx.drawImage(
            originalImg,
            x * scaleX,
            y * scaleY,
            w * scaleX,
            h * scaleY,
            0,
            0,
            w,
            h
          );

          const newImg = new Image();
          newImg.onload = () => {
            originalImg = newImg;
            widthInput.value = w; // Size is reset to the cropped pixel size
            heightInput.value = h;
            history = [];
            cropStart = null;
            cropCurrent = null;
            isFilterOn = false;
            tools.filter.classList.remove("active");
            setMode("pen");
            // Re-init with new natural size
            initCanvas(w, h);
            updateUI();
          };
          newImg.src = tempCanvas.toDataURL();
        });

        btnCancelCrop.addEventListener("click", () => {
          setMode("pen");
          redraw();
        });

        // --- Toolbar UI Logic ---
        function setMode(mode) {
          if (mode === "filter") {
            isFilterOn = !isFilterOn;
            tools.filter.classList.toggle("active", isFilterOn);
            redraw();
            return;
          }
          currentMode = mode;
          Object.values(tools).forEach((btn) => {
            if (btn !== tools.filter) btn.classList.remove("active");
          });
          if (tools[mode]) tools[mode].classList.add("active");
          cropPanel.classList.toggle("active", mode === "crop");

          // Options
          toolOptions.innerHTML = "";
          const crosshairTools = ["pen", "highlighter", "eraser", "mosaic"];
          if (crosshairTools.includes(mode)) {
            canvas.style.cursor = "crosshair";
            if (mode !== "eraser" && mode !== "mosaic")
              toolOptions.appendChild(elColor);
            toolOptions.appendChild(elSize);
            toolOptions.appendChild(elSizeLabel);
          } else {
            canvas.style.cursor = "copy";
          }

          if (mode === "sticker") {
            toolOptions.appendChild(elStickerInput);
            toolOptions.appendChild(elSize);
            toolOptions.appendChild(elSizeLabel);
          } else if (mode === "patch") {
            toolOptions.appendChild(elPatchRect);
            toolOptions.appendChild(elPatchCircle);
            toolOptions.appendChild(elColor);
            toolOptions.appendChild(elSize);
            toolOptions.appendChild(elSizeLabel);
          } else if (mode === "text") {
            toolOptions.appendChild(elTextInput);
            toolOptions.appendChild(elColor);
            toolOptions.appendChild(elSize);
            toolOptions.appendChild(elSizeLabel);
            toolOptions.appendChild(lblBg);
            toolOptions.appendChild(elBgColor);
          } else if (mode === "photo") {
            toolOptions.appendChild(elChangePhoto);
            toolOptions.appendChild(elSize);
            toolOptions.appendChild(elSizeLabel);
          }

          if (mode !== "crop") redraw();
        }

        Object.keys(tools).forEach((key) =>
          tools[key].addEventListener("click", () => setMode(key))
        );

        elBgCheck.addEventListener("change", () => {
          elBgColor.disabled = !elBgCheck.checked;
        });
        elPatchRect.addEventListener("click", () => {
          patchShape = "rect";
          elPatchRect.classList.add("active");
          elPatchCircle.classList.remove("active");
        });
        elPatchCircle.addEventListener("click", () => {
          patchShape = "circle";
          elPatchCircle.classList.add("active");
          elPatchRect.classList.remove("active");
        });
        elChangePhoto.addEventListener("click", () => {
          layerInput.click();
        });

        // Size Indicator Update
        elSize.addEventListener("input", () => {
          elSizeLabel.textContent = elSize.value;
        });

        layerInput.addEventListener("change", (e) => {
          handleLayerFile(e.target.files[0]);
          e.target.value = "";
        });
        btnUndo.addEventListener("click", () => {
          if (history.length > 0) {
            history.pop();
            redraw();
          }
        });
        btnReset.addEventListener("click", () => {
          if (confirm("ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
            history = [];
            isFilterOn = false;
            tools.filter.classList.remove("active");
            redraw();
          }
        });

        reformBtn.addEventListener("click", () => {
          if (!originalImg) return;
          // Save using current canvas size (User WYSIWYG)
          const link = document.createElement("a");
          link.download = `reform_${Date.now()}.jpg`;
          // Use highest quality
          canvas.toBlob(
            (blob) => {
              link.href = URL.createObjectURL(blob);
              link.click();
            },
            "image/jpeg",
            0.95
          );
        });

        document
          .getElementById("change-image-btn")
          .addEventListener("click", () => fileInput.click());
        uploadBox.addEventListener("click", () => fileInput.click());
        fileInput.addEventListener("change", (e) => {
          handleFile(e.target.files[0]);
          e.target.value = "";
        });
        ["dragenter", "dragover", "dragleave", "drop"].forEach((eName) => {
          uploadBox.addEventListener(eName, (e) => {
            e.preventDefault();
            e.stopPropagation();
          });
        });
        uploadBox.addEventListener("dragenter", () =>
          uploadBox.classList.add("dragover")
        );
        uploadBox.addEventListener("dragleave", () =>
          uploadBox.classList.remove("dragover")
        );
        uploadBox.addEventListener("drop", (e) => {
          uploadBox.classList.remove("dragover");
          handleFile(e.dataTransfer.files[0]);
        });

        updateUI = () => {
          reformBtn.disabled = true;
        };
      });
    </script>
  </body>
</html>
